# 数据库大作业 设计手册

## 实现功能简介：

### 元数据管理模块：

#### 基础要求

- 实现表的创建、删除
- 实现数据库的创建、删除、切换
- 实现表和数据库的元数据的持久化
- 重启数据库时从持久化的元数据中恢复系统信息

#### 进阶要求

- 表结构的修改（alter）
  - 添加、删除、修改列

### 存储模块

#### 基础要求

- 实现数据记录的持久化
- 实现对记录的增加、删除、修改
- 支持五种数据类型

### 查询模块

#### 基础要求

- 支持select、join-on、where

#### 进阶要求

- 对join操作进行了简单的优化：如果columnname唯一，可以不输入tablename

### 并发控制模块

#### 基础要求

- 采用普通锁协议，实现read committed，serializable的隔离级别

### 重启恢复模块

#### 基础要求

- 实现单一事务的WAL机制，实现写log和读log，在重启时能够恢复记录的数据

#### 进阶要求

- 实现rollback、savepoint等功能，与并发控制总体组成transaction。



## 存储模块设计

### 简介

我们采用框架中提供的结构（B+树）作为项目的存储结构。由于框架中没有提供B+树的一些进阶接口（lower/upper bound），我们组最终选择仅考虑能至少容纳单表所有数据的内存受限情况，并用B+树直接存储数据而不是index。

### 数据类型

数据库支持五种数据类型：Int，Long，Float， Double，和给定长度的String。我们选择包装一个枚举类：`ColumnType`作为相应的常量标识被`Column`类使用。我们选择不在`Entry`类中处理不同数据类型，仅在其中包装了比较、判断相等、转为String等接口，具体的类别信息则放在Column类中管理。

### 数据持久化

我们选择使用Java的序列化功能进行持久化，序列化的对象类型为`ArrayList<Row>`,值为`Table`的成员变量`index`的所有叶节点的`Row`。要从数据文件读取数据，只需要使用反序列化得到的`ArrayList<Row>`对象，反复调用B+树类的`put`函数（由元数据可以从`Row`中得到索引的值）。

`PersistentStorage`类中封装了序列化与反序列化功能。

当服务端启动时进行数据库数据的恢复；持久化则是在`CHECKPOINT`或一个数据库不再使用时进行。

（具体见事务部分）



## 元数据模块设计

### 简介

我们创建了一个`Meta`类用于专门管理表的元数据，`Table`类中也设置了一个类型为Meta的成员变量。

### 元数据文件存储格式

我们以文本的形式来记录元数据信息。

对每一个数据库，我们都会新建一个与其同名的文件夹；对数据库内的每一张表，我们也会在数据库的同名文件夹内新建一个文件夹，用.meta文件存储元数据信息，用.data文件存储表内的数据信息。

同时，我们也会在数据库的同名文件夹内创建一个数据库元数据文件，其中存储所有表的名称。

由于从表的名称就可以获取其元数据和数据存储路径，故不需要另存路径。文件中每一行是一个表名，有多少表就有多少行。

使用这些就可以读取数据库中表的元数据，其包含内容如下：

- 所属数据库名称
- 表名称
- 主索引编号
- 所有表结构原信息

### 持久化与恢复

当服务端启动时进行数据库元数据的恢复（而后根据元数据进行数据的恢复）；数据库、表级别的元数据（即有数据库里有哪些表，表的结构如何）的持久化在`CHECKPOINT`或一个数据库不再使用时进行；`Manager`级别和用户级别的元数据则是在新建、删除数据库、创建用户时立即进行持久化。



## 查询模块设计

### 简介

我们仅使用了较为朴素的查找方法和join方法，并实现了一些简单的查询优化：如果column name唯一，可以join不输入table name。

### 设计思路

* 在parser部分，我们把目标table和目标column、条件等封装入`selectplan`；`selectplan`进行进一步处理，如`condition`和`multicondition`等；

* 之后程序调用`querytable`生成`queryresult`；

* `querytable`确认参数是否正确，如是否有不存在的column、无tablename的column是否在两个表都存在（且不为join条件，例如以column0为join，但两个表均有column1，此时有二义性）等；

* 记录下select的条件，此处只处理了单个`condition`，记录下其column的index、将匹配的值和比较符号；

* 如果是单表查询，就在所有row中选取结果；若为多表join，则遍历两个表，根据join的条件选取row组合。

* 在`querytable`预处理时，扫描metadata，确认select结果中的column的顺序，并在每次选取时将其按照选取的column裁剪。



## 并发控制设计

#### 整体实现

数据库系统参考HSQLDB的默认并发控制机制，基于表级可重入读写锁共实现了三级不同的封锁协议，其相关特性整理如下：

| 隔离级别         | 丢失更新 | 肮读 | 不可重复读 | 虚读 |
| ---------------- | -------- | ---- | ---------- | ---- |
| `READ_COMMITTED` | 否       | 否   | 是         | 是   |
| `SERIALIZABLE`   | 否       | 否   | 否         | 否   |

其相关实现思路整理如下：

- READ_COMMITTED：事务在对表执行写操作之前需获取其写锁（X锁），事务完毕后才释放；事务在对表执行读操作之前需获取其读锁（S锁），操作完毕后即可释放。
- SERIALIZABLE：事务在对表执行写操作之前需获取其写锁（X锁），事务完毕后才释放；事务在对表执行读操作之前需获取其读锁（S锁），事务完毕后才释放。



## 事务模块设计

### 整体实现

* 我们首先修改了sql.g4文件，使得其能够支持事务的相关指令操作
* 事务在对表执行写操作之前需获取其写锁（X锁），事务完毕后才释放；事务在对表执行读操作之前需获取其读锁（S锁），事务完毕后才释放。
* 我们使用`ReentrantReadWriteLock`来管理不同表的锁；
* 在将要进行操作时检查是否能获取锁。在Manager中定义了ISOLATION用于区别是Serializable还是Read Committed，但是在测试中是完全按照Serializable进行测试的。



## 任务分工

| 成员   | 负责工作                     |
| ------ | ---------------------------- |
| 朱昱松 | 数据持久化、增删改功能、日志 |
| 董文冲 | 查询、并发和事务、测试       |
| 徐霈然 | 元数据管理、表的修改         |

